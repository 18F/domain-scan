#!/usr/bin/env python

import os
import glob
import scanners
from scanners import utils
import logging
import csv
import json


# basic setup - logs, output dirs
options = utils.options()
utils.configure_logging(options)
utils.mkdir_p("cache")
utils.mkdir_p("results")


###
# Entry point. `options` is a dict of CLI flags.
###
def run(options=None):

    if not options["_"]:
        logging.error("Provide a CSV file, or domain name.")
        exit()

    domains = options["_"][0]

    # Which scanners to run the domain through.
    chosen = []

    # Clear out existing result CSVs, to avoid inconsistent data.
    for result in glob.glob("results/*.csv"):
        os.remove(result)

    # Inspect a domain and its endpoint behavior over HTTP and HTTPS.
    if options.get("inspect"):
        import scanners.inspect
        if not utils.try_command(scanners.inspect.site_inspector_cmd):
            logging.error("You need `site-inspector` to scan site details.")
            exit()
        chosen.append(scanners.inspect)

    # Analyze a domain's TLS configuration in great detail.
    if options.get("tls"):
        import scanners.tls
        if not utils.try_command(scanners.tls.ssllabs_cmd):
            logging.error("You need `ssllabs-scan` to scan TLS details.")
            exit()
        chosen.append(scanners.tls)

    # Check whether a domain participated in analytics.usa.gov.
    # [Note: Should generalize this to something less gov-specific.]
    if options.get("dap"):
        import scanners.dap
        dap_file = options.get("dap-csv")
        if (not dap_file) or (not dap_file.endswith(".csv")) or (not os.path.exists(dap_file)):
            logging.error("--dap-csv should point to a CSV file.")
            exit()
        scanners.dap.dap_domains = load_domains(dap_file)
        chosen.append(scanners.dap)

    scan_domains(chosen, domains)

###
# Given the selected scanners, and input domains, run each domain
# through each scanner.
#
# Produces a CSV for each scan, with each domain and results.
###
def scan_domains(scanners, domains):

    # Run through each scanner and open a file and CSV for each.
    handles = {}
    for scanner in scanners:
        name = scanner.__name__.split(".")[-1]  # e.g. 'inspect'
        scanner_file = open("results/%s.csv" % name, 'w', newline='')
        scanner_writer = csv.writer(scanner_file)
        scanner_writer.writerow(["Domain"] + scanner.headers)

        handles[scanner] = {
            'file': scanner_file,
            'writer': scanner_writer
        }

    # For each domain, run through each scanner.
    for domain in domains_from(domains):

        for scanner in scanners:
            for row in scanner.scan(domain, options):
                if row:
                    handles[scanner]['writer'].writerow([domain] + row)

    # Close up all the files.
    for scanner in scanners:
        handles[scanner]['file'].close()

    logging.warn("Results written to CSV.")

# Yield domain names from a single string, or a CSV of them.
def domains_from(arg):
    if arg.endswith(".csv"):
        with open(arg, newline='') as csvfile:
            for row in csv.reader(csvfile):
                if (not row[0]) or (row[0].lower().startswith("domain")):
                    continue
                yield row[0].lower()
    else:
        yield arg


# Load the first column of a CSV into memory as an array of strings.
def load_domains(domain_csv):
    domains = []
    with open(domain_csv, newline='') as csvfile:
        for row in csv.reader(csvfile):
            if (not row[0]) or (row[0].lower().startswith("domain")):
                continue
            domains.append(row[0].lower())
    return domains

if __name__ == '__main__':
    run(options)
